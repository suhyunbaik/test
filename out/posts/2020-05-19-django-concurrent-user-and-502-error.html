<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Django 서버에서 동시접속자 증가시 502 발생 문제</title><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta property="og:title" content="Django 서버에서 동시접속자 증가시 502 발생 문제"/><meta name="next-head-count" content="4"/><link rel="preload" href="/test/_next/static/css/64270e95009c71c18378.css" as="style"/><link rel="stylesheet" href="/test/_next/static/css/64270e95009c71c18378.css" data-n-g=""/><link rel="preload" href="/test/_next/static/css/6bffca5348d7a38926b5.css" as="style"/><link rel="stylesheet" href="/test/_next/static/css/6bffca5348d7a38926b5.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/test/_next/static/chunks/main-f094e29a130fd0913879.js" as="script"/><link rel="preload" href="/test/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/test/_next/static/chunks/framework.8952124311421be7a52f.js" as="script"/><link rel="preload" href="/test/_next/static/chunks/commons.8a9058e35fa745bbf02c.js" as="script"/><link rel="preload" href="/test/_next/static/chunks/pages/_app-97b1d9fc1b95c6a753be.js" as="script"/><link rel="preload" href="/test/_next/static/chunks/df2f4768a04bf8778e0feda17bdebe66dead9af1.7a73df8e06444f1fdbed.js" as="script"/><link rel="preload" href="/test/_next/static/chunks/pages/posts/%5Bid%5D-c328b0f962c8fbba879f.js" as="script"/></head><body><div id="__next"><div class="Home_container__1EcsU"><section class="Home_navigation__3h36s"><div><a href="/test/posts/profile">소개</a></div><div><a href="/test">모든 글</a></div></section><section><article><h1 class="utils_headingXl__1XecN">Django 서버에서 동시접속자 증가시 502 발생 문제</h1><div class="utils_lightText__12Ckm">2020-05-19</div><div class="utils_post__39Wet"><p>1.문제
2.uWSGI worker 갯수 증가
3.db connection pool 도입<br>
4.MySQLclient에서 PyMySQL 로 변경<br>
5.uWSGI 에서 gunicorn 으로 변경</p>
<h3>1.문제</h3>
<p>현재 문제가 있는 서버는 평균적으로 분당 1.9만의 리퀘스트를 소화하는데, 동시접속수가 증가하면 ELB 에서 502가 자주 발생한다. 대략 5분당 평균 13개의 502가 발생한다.</p>
<p>Sever</p>
<ul>
<li>Python==2.7</li>
<li>Django==1.11</li>
<li>uWSGI==2.0</li>
<li>MySQLclient</li>
</ul>
<p>이 문제를 해결하려고 여러가지 시도를 해봤다.</p>
<h3>2.uWSGI worker 갯수 증가</h3>
<p>기존 worker 갯수는 2개였다. 이전부터 이 worker 들은 <code>max-requests</code> 옵션에 지정된 리퀘스트를 소화한뒤 정상적으로 종료되는게 아니라, 갑자기 어디선가 발생한 <code>signal 9</code>을 받고 죽는 문제가 있었다. <code>signal 9</code> 이 발생하는 이유는 보통 메모리 부족인데, 파게이트 컨테이너 측정치를 봤을때는 메모리 사용량이 대체로 30%여서 메모리 문제는 아닌 것 같았다. 내 추측에는 아마 worker 가 2개 뿐이니 <code>max-request</code>에 지정된 리퀘스트 수 보다 더 많은 리퀘스트를 받아서 uWSGI에서 signal 9  을 발생시켜 worker 를 강제로 죽이고, worker 가 둘 다 죽어서 워커가 다시 respawn 될때까지 기다리는 상황이 빈번하게 발생하고, 이렇게 spawn된 worker가 없을때 들어온 리퀘스트가 502가 발생한다고 생각했다. 이러한 상황을 방지하기 위해서 <code>max-requests-delta</code> 옵션이 있지만 효과가 없는 것 같았다. (나중에 알게 되었는데 <code>max-requests-delta</code> 옵션은 <code>uWSGI >= 2.1</code> 부터 효과가 있다고 한다.) 그래서 스테이징에 worker 수를 증가시켜 테스트를 했는데 2, 4, 6개였을때는 별 차이가 없었지만 8, 12, 16 등등 수를 크게 증가시킬수록 500대 에러 발생률이 크게 낮아졌다. <code>signal 9</code> 문제도 더이상 발생하지 않았다.</p>
<p>그런데 worker 수를 증가시키지 말자는 의견이 있어서 이 방법은 가장 마지막에 시도할 해결방법으로 제쳐두었다. 반대 이유는 보통 이상적인 worker 갯수 산정을 <code>core x 2</code> 로 계산하기 때문에, worker 수가 너무 낮게 잡혀있는건 맞지만, 워커 갯수를 12, 15 정도로 증가시킬거라면 그냥 파게이트 컨테이너를 1대 더 띄우는게 낫다는 이유였다.</p>
<h3>3. db connection pool 도입</h3>
<p>uWSGI 에서 몽키 패치를 해도 디비 커넥션이 병목현상이 디비 커넥션에서 일어난다고 생각했다. 그래서 <code>sqlalchemy</code> 디비 커넥션 풀링을 도입해서 스테이징에서 테스트 했다.
<img src="/test/2020-05-19-django-concurrent-user-and-502-error/db_connection_with_pooling.png" alt="db connection with pooling"><br>
커넥션 풀링 도입 전과 후과 다르다. 그러나 동시접속자 수가 증가하면 여전히 502가 발생했다.</p>
<h3>4. mysqlclient 에서 pymysql 로 변경</h3>
<p>uWSGI 에서는 gevent 쓰려면 몽키패치를 해야한다. 몽키패치는 pure python 에서만 효과를 발휘하는데, 현재 사용하고 있는 mysqlicent 는 cpython 이라서 몽키패치가 안된다. 결국 gevent 를 100개 spawn하더라도, mysqliclient가 몽키패치 되지않아 gevent 1개가 끝날때까지 나머지가 블로킹 될거고 이 부분이 병목이 된다는 생각이 들었다. pymysql은 pure python 이지만 mysqlclient 에 비교하면 성능이 60%나 떨어진다고 한다. 그러나 성능이 떨어지더라도 몽키패치가 되면 성능이 상쇄될거라고 생각해서 pymyql 로 변경했다.</p>
<h3>5. uWSGI 에서 gunicorn 으로 변경</h3>
<p>pymysql 로 라이브러리를 변경 한 뒤에 uWSGI 의 몽키패치가 효과가 있었지만, 동시접속사 수 문제에서는 여전히 큰 효과가 없었다. 그리고 uWSGI 를 잘쓰려면 학습해야하는데 우선 피쳐 개발이 급해서 학습할 시간이 없고, 대략 gunicorn 성능이 더 좋다고 해서 gunicorn 옮기기로 결정했다. 아래는 gunicorn 으로 변경 후 500대 에러의 변화다.
<img src="/test/2020-05-19-django-concurrent-user-and-502-error/gunicorn_deploy.png" alt="gunicorn deploy"></p>
<h3>References</h3>
<p>*<a href="https://stackoverflow.com/questions/48977889/avoid-that-all-workers-get-re-spawned-at-the-same-time">Avoid all workers get respawned</a><br>
*<a href="https://wiki.openstack.org/wiki/PyMySQL_evaluation">PyMySQL evaluation</a></p>
</div></article></section></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"2020-05-19-django-concurrent-user-and-502-error","contentHtml":"\u003cp\u003e1.문제\n2.uWSGI worker 갯수 증가\n3.db connection pool 도입\u003cbr\u003e\n4.MySQLclient에서 PyMySQL 로 변경\u003cbr\u003e\n5.uWSGI 에서 gunicorn 으로 변경\u003c/p\u003e\n\u003ch3\u003e1.문제\u003c/h3\u003e\n\u003cp\u003e현재 문제가 있는 서버는 평균적으로 분당 1.9만의 리퀘스트를 소화하는데, 동시접속수가 증가하면 ELB 에서 502가 자주 발생한다. 대략 5분당 평균 13개의 502가 발생한다.\u003c/p\u003e\n\u003cp\u003eSever\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePython==2.7\u003c/li\u003e\n\u003cli\u003eDjango==1.11\u003c/li\u003e\n\u003cli\u003euWSGI==2.0\u003c/li\u003e\n\u003cli\u003eMySQLclient\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 문제를 해결하려고 여러가지 시도를 해봤다.\u003c/p\u003e\n\u003ch3\u003e2.uWSGI worker 갯수 증가\u003c/h3\u003e\n\u003cp\u003e기존 worker 갯수는 2개였다. 이전부터 이 worker 들은 \u003ccode\u003emax-requests\u003c/code\u003e 옵션에 지정된 리퀘스트를 소화한뒤 정상적으로 종료되는게 아니라, 갑자기 어디선가 발생한 \u003ccode\u003esignal 9\u003c/code\u003e을 받고 죽는 문제가 있었다. \u003ccode\u003esignal 9\u003c/code\u003e 이 발생하는 이유는 보통 메모리 부족인데, 파게이트 컨테이너 측정치를 봤을때는 메모리 사용량이 대체로 30%여서 메모리 문제는 아닌 것 같았다. 내 추측에는 아마 worker 가 2개 뿐이니 \u003ccode\u003emax-request\u003c/code\u003e에 지정된 리퀘스트 수 보다 더 많은 리퀘스트를 받아서 uWSGI에서 signal 9  을 발생시켜 worker 를 강제로 죽이고, worker 가 둘 다 죽어서 워커가 다시 respawn 될때까지 기다리는 상황이 빈번하게 발생하고, 이렇게 spawn된 worker가 없을때 들어온 리퀘스트가 502가 발생한다고 생각했다. 이러한 상황을 방지하기 위해서 \u003ccode\u003emax-requests-delta\u003c/code\u003e 옵션이 있지만 효과가 없는 것 같았다. (나중에 알게 되었는데 \u003ccode\u003emax-requests-delta\u003c/code\u003e 옵션은 \u003ccode\u003euWSGI \u003e= 2.1\u003c/code\u003e 부터 효과가 있다고 한다.) 그래서 스테이징에 worker 수를 증가시켜 테스트를 했는데 2, 4, 6개였을때는 별 차이가 없었지만 8, 12, 16 등등 수를 크게 증가시킬수록 500대 에러 발생률이 크게 낮아졌다. \u003ccode\u003esignal 9\u003c/code\u003e 문제도 더이상 발생하지 않았다.\u003c/p\u003e\n\u003cp\u003e그런데 worker 수를 증가시키지 말자는 의견이 있어서 이 방법은 가장 마지막에 시도할 해결방법으로 제쳐두었다. 반대 이유는 보통 이상적인 worker 갯수 산정을 \u003ccode\u003ecore x 2\u003c/code\u003e 로 계산하기 때문에, worker 수가 너무 낮게 잡혀있는건 맞지만, 워커 갯수를 12, 15 정도로 증가시킬거라면 그냥 파게이트 컨테이너를 1대 더 띄우는게 낫다는 이유였다.\u003c/p\u003e\n\u003ch3\u003e3. db connection pool 도입\u003c/h3\u003e\n\u003cp\u003euWSGI 에서 몽키 패치를 해도 디비 커넥션이 병목현상이 디비 커넥션에서 일어난다고 생각했다. 그래서 \u003ccode\u003esqlalchemy\u003c/code\u003e 디비 커넥션 풀링을 도입해서 스테이징에서 테스트 했다.\n\u003cimg src=\"/test/2020-05-19-django-concurrent-user-and-502-error/db_connection_with_pooling.png\" alt=\"db connection with pooling\"\u003e\u003cbr\u003e\n커넥션 풀링 도입 전과 후과 다르다. 그러나 동시접속자 수가 증가하면 여전히 502가 발생했다.\u003c/p\u003e\n\u003ch3\u003e4. mysqlclient 에서 pymysql 로 변경\u003c/h3\u003e\n\u003cp\u003euWSGI 에서는 gevent 쓰려면 몽키패치를 해야한다. 몽키패치는 pure python 에서만 효과를 발휘하는데, 현재 사용하고 있는 mysqlicent 는 cpython 이라서 몽키패치가 안된다. 결국 gevent 를 100개 spawn하더라도, mysqliclient가 몽키패치 되지않아 gevent 1개가 끝날때까지 나머지가 블로킹 될거고 이 부분이 병목이 된다는 생각이 들었다. pymysql은 pure python 이지만 mysqlclient 에 비교하면 성능이 60%나 떨어진다고 한다. 그러나 성능이 떨어지더라도 몽키패치가 되면 성능이 상쇄될거라고 생각해서 pymyql 로 변경했다.\u003c/p\u003e\n\u003ch3\u003e5. uWSGI 에서 gunicorn 으로 변경\u003c/h3\u003e\n\u003cp\u003epymysql 로 라이브러리를 변경 한 뒤에 uWSGI 의 몽키패치가 효과가 있었지만, 동시접속사 수 문제에서는 여전히 큰 효과가 없었다. 그리고 uWSGI 를 잘쓰려면 학습해야하는데 우선 피쳐 개발이 급해서 학습할 시간이 없고, 대략 gunicorn 성능이 더 좋다고 해서 gunicorn 옮기기로 결정했다. 아래는 gunicorn 으로 변경 후 500대 에러의 변화다.\n\u003cimg src=\"/test/2020-05-19-django-concurrent-user-and-502-error/gunicorn_deploy.png\" alt=\"gunicorn deploy\"\u003e\u003c/p\u003e\n\u003ch3\u003eReferences\u003c/h3\u003e\n\u003cp\u003e*\u003ca href=\"https://stackoverflow.com/questions/48977889/avoid-that-all-workers-get-re-spawned-at-the-same-time\"\u003eAvoid all workers get respawned\u003c/a\u003e\u003cbr\u003e\n*\u003ca href=\"https://wiki.openstack.org/wiki/PyMySQL_evaluation\"\u003ePyMySQL evaluation\u003c/a\u003e\u003c/p\u003e\n","title":"Django 서버에서 동시접속자 증가시 502 발생 문제","date":"2020-05-19"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2020-05-19-django-concurrent-user-and-502-error"},"buildId":"iS-ZRwUJjhv5CC6AEFHqq","assetPrefix":"/test","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/test/_next/static/chunks/polyfills-2473c6643d514137e5d1.js"></script><script src="/test/_next/static/chunks/main-f094e29a130fd0913879.js" async=""></script><script src="/test/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/test/_next/static/chunks/framework.8952124311421be7a52f.js" async=""></script><script src="/test/_next/static/chunks/commons.8a9058e35fa745bbf02c.js" async=""></script><script src="/test/_next/static/chunks/pages/_app-97b1d9fc1b95c6a753be.js" async=""></script><script src="/test/_next/static/chunks/df2f4768a04bf8778e0feda17bdebe66dead9af1.7a73df8e06444f1fdbed.js" async=""></script><script src="/test/_next/static/chunks/pages/posts/%5Bid%5D-c328b0f962c8fbba879f.js" async=""></script><script src="/test/_next/static/iS-ZRwUJjhv5CC6AEFHqq/_buildManifest.js" async=""></script><script src="/test/_next/static/iS-ZRwUJjhv5CC6AEFHqq/_ssgManifest.js" async=""></script></body></html>